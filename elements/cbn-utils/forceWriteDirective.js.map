{"version":3,"file":"forceWriteDirective.js","sourceRoot":"","sources":["forceWriteDirective.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,QAAQ,EAAE,OAAO,EAAC,MAAM,KAAK,CAAA;AACpD,OAAO,EACH,SAAS,EACT,SAAS,EAGT,QAAQ,GACX,MAAM,eAAe,CAAC;AACvB,OAAO,EAAC,kBAAkB,EAAE,iBAAiB,EAAC,MAAM,uBAAuB,CAAA;AAE3E;;;;;;;;;EASE;AACF,MAAM,mBAAoB,SAAQ,SAAS;IACvC,YAAY,QAAkB;QAC1B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IACI,CAAC,CACG,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,QAAQ;YACnC,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,SAAS;YACpC,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,iBAAiB,CAC/C,EACH,CAAC;YACC,MAAM,IAAI,KAAK,CACX,gEAAgE,CACnE,CAAC;QACN,CAAC;QACD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,EAAE,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;QAC5E,CAAC;IACL,CAAC;IAED,MAAM,CAAC,KAAc;QACjB,OAAO,KAAK,CAAC;IACjB,CAAC;IAEQ,MAAM,CAAC,IAAmB,EAAE,CAAC,KAAK,CAA4B;QACnE,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,OAAO,EAAE,CAAC;YAC1C,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,QAAQ,EAAE,CAAC;YAClC,8DAA8D;YAC9D,0CAA0C;YAC1C,uBAAuB;YACvB,IAAI;QACR,CAAC;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,iBAAiB,EAAE,CAAC;YAClD,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;gBACzC,OAAO,QAAQ,CAAC;YACpB,CAAC;QACL,CAAC;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,SAAS,EAAE,CAAC;YAC1C,IAAI,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC/C,OAAO,QAAQ,CAAC;YACpB,CAAC;QACL,CAAC;QACD,sEAAsE;QACtE,yBAAyB;QACzB,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxB,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,SAAS,CAAC,mBAAmB,CAAC,CAAC","sourcesContent":["import {AttributePart, noChange, nothing} from \"lit\"\r\nimport {\r\n    directive,\r\n    Directive,\r\n    DirectiveParameters,\r\n    PartInfo,\r\n    PartType,\r\n} from 'lit/directive';\r\nimport {isSingleExpression, setCommittedValue} from \"lit/directive-helpers\"\r\n\r\n/*\r\nhttps://github.com/Polymer/lit-html/issues/877\r\nhttps://github.com/Polymer/lit-html/issues/872#issuecomment-474698152\r\nDoes not work with live, cause when we change the model,\r\nthe select doesn't throw a changed event and we dont populate the model with _label\r\n\r\nconst forceWrite = directive((value) => (part) => {\r\n    part.setValue(value);\r\n});\r\n*/\r\nclass ForceWriteDirective extends Directive {\r\n    constructor(partInfo: PartInfo) {\r\n        super(partInfo);\r\n        if (\r\n            !(\r\n                partInfo.type === PartType.PROPERTY ||\r\n                partInfo.type === PartType.ATTRIBUTE ||\r\n                partInfo.type === PartType.BOOLEAN_ATTRIBUTE\r\n            )\r\n        ) {\r\n            throw new Error(\r\n                'The `live` directive is not allowed on child or event bindings'\r\n            );\r\n        }\r\n        if (!isSingleExpression(partInfo)) {\r\n            throw new Error('`live` bindings can only contain a single expression');\r\n        }\r\n    }\r\n\r\n    render(value: unknown) {\r\n        return value;\r\n    }\r\n\r\n    override update(part: AttributePart, [value]: DirectiveParameters<this>) {\r\n        if (value === noChange || value === nothing) {\r\n            return value;\r\n        }\r\n        const element = part.element;\r\n        const name = part.name;\r\n\r\n        if (part.type === PartType.PROPERTY) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            // if (value === (element as any)[name]) {\r\n            //     return noChange;\r\n            // }\r\n        } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\r\n            if (!!value === element.hasAttribute(name)) {\r\n                return noChange;\r\n            }\r\n        } else if (part.type === PartType.ATTRIBUTE) {\r\n            if (element.getAttribute(name) === String(value)) {\r\n                return noChange;\r\n            }\r\n        }\r\n        // Resets the part's value, causing its dirty-check to fail so that it\r\n        // always sets the value.\r\n        setCommittedValue(part);\r\n        return value;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks binding values against live DOM values, instead of previously bound\r\n * values, when determining whether to update the value.\r\n *\r\n * This is useful for cases where the DOM value may change from outside of\r\n * lit-html, such as with a binding to an `<input>` element's `value` property,\r\n * a content editable elements text, or to a custom element that changes it's\r\n * own properties or attributes.\r\n *\r\n * In these cases if the DOM value changes, but the value set through lit-html\r\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\r\n * it alone. If this is not what you want--if you want to overwrite the DOM\r\n * value with the bound value no matter what--use the `live()` directive:\r\n *\r\n * ```js\r\n * html`<input .value=${live(x)}>`\r\n * ```\r\n *\r\n * `live()` performs a strict equality check against the live DOM value, and if\r\n * the new value is equal to the live value, does nothing. This means that\r\n * `live()` should not be used when the binding will cause a type conversion. If\r\n * you use `live()` with an attribute binding, make sure that only strings are\r\n * passed in, or the binding will update every render.\r\n */\r\nexport const forceWrite = directive(ForceWriteDirective);\r\n\r\n/**\r\n * The type of the class that powers this directive. Necessary for naming the\r\n * directive's return type.\r\n */\r\nexport type {ForceWriteDirective};"]}